@ 모든 패턴들의 "구조"와 "구현"의 분리를 이해하고 그것의 장점을 최대한 살려야 한다.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# 생성 패턴 : 객체의 생성과 관련된 패턴으로 객체의 생성과 참조 과정을 캡슐화하여 객체가 생성되거나 변경되어도 크게 영향을 받지 않도록하여 프로그램의 "유연성"을 더해준다.

* "팩토리 메소드" 패턴 : 팩토리 메소드 패턴에서 템플릿 메소드 패턴이 사용되는 것을 안다.
   우리가 나중에 다른 아이템을 생성할 때 다른 소스 변경(Main같은)이 필요가 없다.
   ** 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴이다.
   ** 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다.

* 싱글톤 패턴 : 싱글톤 패턴을 통해서 하나의 인스턴스만 생성하도록 구현할 수 있다. 하나만 생성해야할 인스턴스를 위한 패턴
   객체 : 속성과 기능을 갖춘 것
   클래스 : 속성과 기능을 정의한 것 (자동차 설계도)
   인스턴스 : 클래스 중 실제 구현된 것 (만들어진 자동차) 
   ex) 인스턴스를 호출할 때 로그를 찍어주는 소스를 추가할 때, 사용자 방문 카운트할 때 
   ** 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없다.
   ** 클래시 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화할 수 있다.

* 프로토타입 패턴 : 프로토 타입 패턴을 통해서 복잡한 인스턴스를 복사할 수 있다.
   생산비용이 높은 인스턴스를 복사를 통해서 쉽게 생성할 수 있도록 하는 패턴	
	1. 종류가 너무 많아서 클래스로 정리되지 않는 경우
        	2. 클래스로부터 인스턴스 생성이 어려운 경우 	 
   ** 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴이다.
   ** 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용한다.

* 빌더 패턴 : 복잡한 단계가 필요한 인스턴스 생성을 빌더 패턴을 통해서 구현할 수 있다. 많은 변수를 가진 객체의 생성을 가독성 높도록 코딩할 수 있다.
   복잡한 단계를 거쳐야 생성되는 객체의 구현을 서브 클래스에게 넘겨주는 패턴
   ** 작게 분리된 인스턴스를 건축하듯이 조합하여 객체를 생성한다.
   ** 객체의 생성과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있다.

* 추상팩토리 패턴 : 관련있는 객체의 생성을 가상화할 수 있다. 생성 부분의 가상화 / 관련있는 객체
   ** 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현한다.
   ** 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능하다.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# 구조 패턴 : 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴으로 구조가 복잡한 시스템을 개발하기 쉽게 도와준다.

* "어댑터" 패턴 : 알고리즘을 요구사항에 맞춰 사용할 수 있다.
   특정한 알고리즘을 가진 클래스를 Adapter역할을 하는 인터페이스와 하위클래스를 구성하여 Main과 이미 
   정해진 알고리즘을 수정안하더라도 Adapter 인터페이스를 거치면 각각 다른 결과가 도출된다.
   ** 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴이다.
   ** 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용한다.

* "브리지" 패턴 : 기능 계층과 구현 계층의 분리. 어댑터 패턴과 브릿지패턴을 연결하여 이해한다.
   ** 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구현한 패턴이다.
   ** 기능과 구현을 두 개의 별로 클래스로 구현한다.

* "컴포지트" 패턴 : 컨테이너와 내용물을 같게 다루기고 컴퍼짓 패턴을 이용하여 트리구조를 구현할 수 있다.
   ** 여러 객체를 가진 복합 객체와 단일 객체를 구분없이 다루고자 할 때 사용하는 패턴이다.
   ** 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있다.

* "데코레이터" 패턴 : 동적으로 책임 추가가 필요할 때 데코레이터 패턴을 사용할 수 있다. 동적, 책임 추가
   ** 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴이다.
   ** 임의로 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현한다.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

# 행위 패턴 : 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도가 느슨해지도록 도와준다.

* "전략" 패턴 : 인터페이스, 델리게이트 개념을 이해하여 사용한다.
   1개의 인터페이스에서 같은 메소드를 받는 3개의 클래스로 갈라져서 클라이언트가 접근점 역할을 하는 클래스에 Delegate메서드를 구현하여 사용한다.
   ** 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴이다.
   ** 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향없이 알고리즘의 변경이 가능하다.

* "템플릿 메소드" 패턴 : 일정한 프로세스를 가진 요구사항을 템플릿 메소드 패턴을 이용하여 구현할 수 있다.
   지속적인 발전이 있어야하는 "보안"같은 분야에서 효과적인 유지보수! 
   구현하려는 알고리즘이 "일정한 프로세스(여러 단계로 나눌 수 있을 때)"가 있고 "변경 가능성"이 있을 때 사용한다.
   알고리즘의 구조를 메소드에 정의하고 하위 클래스에서 알고리즘 구조의 변경없이 알고리즘을 재정의 하는 패턴.
   1. 알고리즘을 여러 단계로 나눈다.   
   2. 나눠진 알고리즘의 단계를 메소드로 선언한다.
   3. 알고리즘을 수행할 템플릿 메소드를 만든다.
   4. 하위 클래스에서 나눠진 메소드들을 구현한다.
   ** 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴이다.
   ** 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해준다.

* "방문자" 패턴 : 방문자 패턴을 이용하여 객체(클래스)에서 처리(메소드)를 분리하여 사용할 수 있다. 객체, 처리, 분리
   ** 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴이다.
   ** 분리된 처리 기능은 각 클래스를 방문하여 수행한다. 

* "책임 연쇄" 패턴 : 다양한 처리 방식을 유연하게 연결할 수 있다. 유연한처리, 동적
   ** 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴이다.
   ** 요청을 처리할 수 있는 각 개체들이 고리로 묶여있어 요청이 해결 될 때까지 고리를 따라 책임이 넘어간다.


