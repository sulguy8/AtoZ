?~ 이후의 요청값을 map으로 생각할 것.
getParameter 하면 무조건 0번째것 갖고옴. 따라서 여러개 갖고오려면 getParameterValue.
무조건 1 request이면 1 response. 오류뜨는것도 response!
getParameter는 기본적으로 map으로 저장함.

## JSP 처리과정(99pg) PPT로 발표하기.
WebContent에
1.jsp
2.jsp
3.jsp
4.jsp 4개의 .jsp 페이지가 만들어진다면?

톰캣(WAS, web이 파일의 존재는 알지만 4개의 페이지를 바로 자바로 만들지 않음.

처음 요청하게된다면...
1-1. 내가 요청을 1.jsp부르면 그때 1이됨.
1-2. 이때 자바파일이 만들어짐!
1-3. 자바파일을 실행하는게 아니야! 요청을 했을 때만 자바 코드를 컴파일을 시킴(전부다 시키는것이 아님). 결국 1.jsp.class만듬 이걸 실행을 함.
2-2 ~ 3 은 처음 요청했을때까지 진행.
똑같은걸 요청하면 1-1을 안타고 2-1을 탐. 바로 1-3을 실행시켜버림.
만약에 jsp소스를 수정했을 때 다시 1-1순서로 시작.


내리는게 "플러쉬"
한번 내리고 바로 내리는게 의미가 있나? 물찰때까지 기다려야지. 물이 채워지는 시간까지 기다려야 플러쉬가 의미가 있구나!(안된다는건 아님)
물찰때까지 기다리는게 "버퍼" (쌓아놓았다가 한번에 보내는게 "버퍼", 하나하나 읽으면서 보내면 속도가 느리기때문에 미리 읽어둔것들을 저장해둠.)

ctrl shift r 파일명으로 파일 찾기.

별명, 알리아스. select *(여기에 생략되어있음) 


쿼리에서 합집합은 join이나, 아예 조건을 안주거나.
관계를 증명하면 교집합. 증명이 안되면 합집합.


create table books_info(
bi_num number PRIMARY key,
bi_image varchar2(300), 
bi_name varchar2(300) not null,
bi_type char(2) default '00',
bi_star number(4,2) default 0.0,
bi_credat char(8) not null,
bi_desc varchar2(4000) not null
);

create table books_type(
bt_num char(2) not null primary key,
bt_name varchar(30) not null
);




select bi.bi_name, bi.bi_type, 
(select bt_name from books_type where bt_num = bi_type)
from books_info bi; 

select * from books_info;
select * from books_type;

update books_info set bi_type = '00'
where bi_num = '12';

select bi.bi_num, bi.bi_image, bi.bi_name, bi.bi_desc, bi.bi_star, bi.bi_credat, 
(select bt.bt_name from books_type bt where bt.bt_num = bi.Bi_type) bi_type
from books_info bi;

select * from books_info, books_type
where bi_type = bt_num
;
