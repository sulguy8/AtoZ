https://blog.naver.com/spdlqjdudghl

https://beomy.tistory.com/43  - mvp 패턴

https://www.data.go.kr/



# 함수
log(10) + 5 // 로그함수
sqrt(25) // 제곱근
max(5,3,2) // 가장큰 값
min()
abs(-10)
factorial(5)
sin(pi/2), cos(), tan()

# 유용한 함수들
** apply : 행렬이나 데이터 프레임을 행 단위로, 또는 열 단위로 행렬의 합이나 평균, 표준편차 등을 계산할 때 씀.
apply(no.patients,1,sum) // 여기서 1은 행을 의미, 2는 열. 1과 2로 행렬을 구분한다.
lapply(listPatients$no.patients, mean) // 데이터타입을 list로 리턴.
sapply(listPatients$no.patients, mean) // 데이터타입이 벡터. 평균내는 두가지 형태의 함수

** tapply : 벡터 등에 있는 데이터를 특정 기준으로 묶어 그룹마다 특정 함수 적용
tapply(weigth.furit,mean) // 과일을 기준으로 평균을 구해라.
tapply(iris$Sepal.Width, iris$Species, sum) // 종을 기준으로

# 원하는 정보 가져오기
IR.1 <- subset(iris, Species=="setosa")
IR.2 <- subset(iris, Sepal.Length>5.0 & Sepal.Width>4.0)
IR.2[, c(2,4)]

* 구분할 것.
iris["Species"] // 벡터, 매트릭스와 데이터프레임 모두 가능.
iris[,"Species"] // 데이터프레임, 데이터프레임만 가능. iris[,5]와 같다.
iris$Species // 벡터. 데이터프레임만 가능

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
# 단축키
* ctrl + shift + enter // 전체실행

# library install 순서!
1. packages에서 다운받고
2. install.packages("ggplot2") // 설치한 패키지 불러오기
3. library(ggplot2) 		// install된거 메모리올리기
 
# 외부파일 읽어오기
* tips=read.csv('https://raw.githubusercontent.com/mwaskom/seaborn-data/master/tips.csv') 

# 통계내기
* summary(tips) // 요약 통계량
  str(tips) // 데이터 프레임에 저장된 데이터의 갯수, 변수, 자료형, 저장된 데이터의 일부를 보여줌.

# 데이터타입
숫자형 1, 2, 3, -4, 12.8
문자형 'TOM', "JANE"
논리형 TRUE, FALSE
특수값 null, na(missing value), NaN, Inf, -Int
* w <- c(1,2,3,"a","b","C") // 전부다 문자열로 바뀜

# 데이터 셋의 기본정보 확인.
dim(iris) 		// 행, 열을 파악할 때
nrow(iris)		// 행을 파악할 때
ncol(iris)		// 열을 파악할 때
colnames(iris)
head(iris)
tail(iris)
str(iris) 		// 데이터 분석
unique(iris[,5]) 	// 중복제거
table(iris[,"Species"]) 	// 품종의 종류별 개수 세기

# 표 그리기
* 벡터는 1차원 배열 데이터 ex) 몸무게 30, 32, 38
  매트리스, 데이터프레임은 2차원 배열 데이터 x, y로 row와 col로 구성
* v2 <- c(1,2,5, 50:90) // 1,2,5 찍고 50~90까지
* v3 <- seq(1,101,3) // 1부터 3씩 더하면서 101번까지 찍고 seq해라
* 2차원으로 바꾸기
  score <- c(90,85,60)
  names(score) <- c("A","B","C") // 열의 이름 정하기

# 그래프 실행
tips%>%ggplot(aes(size)) + geom_histogram()
tips%>%ggplot(aes(total_bill, tip)) + geom_point()
tips%>%ggplot(aes(total_bill, tip)) + geom_point(aes(col=day))
tips%>%ggplot(aes(total_bill, tip)) + geom_point(aes(col=day, pch=sex), size=3)

# 반복문
  v4 <- rep(1:5, times=3)
  v5 <-  rep(c(1,5,9), times=3)

# 배열
* v1[10] // 벡터값의 10번째방
* 배열 방으로 보는 방법
d <- c(1,4,3,7,8)
d[c(1,3,5)]
d[1:3]
d[seq(1,5,2)] 	// 방번호임.
d[-2]		// 2번째방 빼기
d[-c(3:5)]
* 정렬하기
sort(d, decreasing = TRUE)

# 리스트 : 서로 다른 자료형들의 값들을 1차원 배열에 저장하고 다룰 수 있다
  my.info <- list(name='Tom','Jerry', age=60, status=TRUE, score=ds)
  my.info[[5]]

# 팩터 : 문자형 데이터가 저장된 벡터의 일종. 성별이나 혈액형, 선호 정당 등과 같이 저장할 문자값들이 fix되어있을때 팩터를 사용. 레벨이 있음
* 팩터의 선언
bt <- c('A','B','C','O','AB','A')  // 만약에 여기다 E를 넣으면 오류남.
bt.new <-  factor(bt)
levels(bt.new)

# 매트릭스 : 2차원 데이터라고도 함.(1차원은 벡터) 키,몸무게,나이 등 여러 주제의 데이터. 벡터들의 모임이라 할 수 있다. *** 모든 셀의 데이터타입이 같다!
* 행은 관측값(observation), 열은 변수(variable)라고 함
* z <- matrix(1:20, nrow=4, ncol=5) // 1~20까지 열단위로 먼저 들어감.
** z2 <- matrix(1:20, nrow=4, ncol=5, byrow=T) // 행단위로 먼저 들어감.
* m1 <- cbind(x,y) // 바인드로 행 묶어버리기
** m2 <- rbind(x,y) // 바인드로 열 묶어버리기
* 행과 열 자리바꾸기
z <- matrix(1:20, nrow=4, ncol=5)
t(z)
* 조회방법
z[2,4] // 조회방법
z[1:2,] // 1행과 2행만 다 나와라
z[,c(1,4)] // 1열과 4열만 다 나와라
z['a','i']
* 매트릭스 이름 정하기
rownames(z) <- c('a','b','c','d')
colnames(z) <- c('e','f','g','h','i')

# 데이터 프레임 : 자료형이 다른 컬럼으로 구성되어있다
* 데이터 프레임 만드는 방법
city <- c("seoul","tokyo","washington")
rank <- c(1,3,2)
city.info <- data.frame(city,rank)
city.info

## 매트릭스와 데이터 프레임에서 사용하는 함수.
colSums(iris[,-5]) 	// 열별 합계
colMeans(iris[,-5])	// 열별 평균
rowSums(iris[,-5])
* 매트릭스와 데이터프레임의 자료구조 확인
class(iris) // iris 데이터셋의 자류구조 확인
is.matrix(iris), is.data.frame(iris)
* 매트릭스와 데이터프레임의 자료구조 변환
st <- data.frame(state.x77)
iris.m <- as.matrix(iris[,1:4])

# 리스트 : 서로 다른 기본 데이터형을 갖는자료 구조를 포함함. 데이터 프레임보다 넓은 의미의 데이터 모임. 
            *** 데이터 프레임과 달리 모든 속성의 크기가 같을 필요가 없음
ds <- c(90,85,70,84)
my.info <- list(name='TOM',age=60, status=TRUE, score=ds) // 리스트 만드는 방법
my.info[[4]] = my.info[["score"]] = my.info$score

patients = data.frame(name=c("철수","춘향","길동"), age= c(22,20,25), gender = factor(c("M","F","M")), blood.type = factor(c("A","O","B")))
no.patients = data.frame(day=c(1:6), no=c(50,60,70,80,90,65))
listPatients = list(patients, no.patients)
listPatients = list(patients = patients, no.patients = no.patients) // 요소에 이름주기
listPatients$patients // 위의 이름으로 출력가능.
listPatients[[1]]
listPatients[["patients"]]



** 패키지와 함수 // RStudio에서 우측하단의 인스톨을 통하여 설치해야 함.
base 기본 패키지
readr 패키지
data.table 패키지
feather 패키지

** 파일 형식 변환 // 엑셀파일에 테이블 형태의 데이터가 저장된 상태에서 .csv형태로 변환하여 R에서 .csv파일을 읽음. 이 파일은 데이터 프레임 형태로 저장됨.
setwd("C:/source") // 여기 경로의 폴더에 존재하는 csv(Comma-Separated Values)파일 갖고오는 것.(setworkingdirectory의 약자)
air <- read.csv("airquality.csv", header=T) // csv파일 읽을때
head(air)
air <- read.table("airquality.txt", header=T) // txt파일 읽을때

* csv는 이런 파일임.
name,korean,english
조씨,60,60
김씨,70,70
이씨,80,50	
박씨,60,50	

* txt파일은 띄어쓰기로 구분
name korean english
조씨 60 60
김씨 70 70
이씨 80 50	
박씨 60 50

write.csv(listPatients, file="c://source/output.csv", quote=F)	 // csv파일로 저장
write.table(listPatients, file="c://source/output2.txt", quote=F) // 텍스트파일로 저장 quote=f는 따옴표가 없음.

setwd("C:/source")
my.iris <- subset(iris, Species='Setosa')
write.csv(my.iris, "my_iris.csv", row.names=F) // row.names=F는 행번호 붙이지 않을 때.



## 조건문
job.type <- 'A'
if(job.type == 'B'){
    bonus <- 200
} else { 
    bonus <- 100
}
print(bonus)

a <- 10
b <- 20
c <- ifelse(a>b, a,b) // 3항연산자. true면 a, false면 b

x=c(-5:5)
options(digits=3) // 숫자 표현 시 유효자릿수를 3자리로 설정
sqrt(x) // NaN이 포함되어있어서 오류발생! sqrt는 루트를 의미함.
sqrt(ifelse(x>=0, x, NA)) // 따라서 이렇게 해결해줘야 함.
## 반복문
for (반복변수 in 반복범위){
	반복할 명령문(들)
}

for(i in 1:5){
  print(i);
}

for(i in 1:9){
  cat('2*', i, '=', 2*i,'\n');
}	// 구구단의 2단 만들기

for(i in 1:20){
  if(i%%2==0){
    print(i)
  }
} 	// 짝수만 출력하기

* 강제로 값 바꾸기
x <- iris
x[1,2] <- NA; x[1,3] <- NA
x[2,3] <- NA; x[3,4] <- NA

# 데이터 프레임의 열별 결측값 확인
** for문을 이용한 방법
for(i in 1:ncol(x)){
  this.na <-  is.na(x[,i]) // na는 NaN. 그게 몇개가 있느냐
  cat(colnames(x)[i], "\t", sum(this.na), "\n")
}

** apply를 이용한 방법
col_na <-  function(y){
  return(sum(is.na(y)))
}
na_count <-  apply(x, 2, FUN=col_na)
na_count

# 데이터 프레임의 행별 결측값 확인
rowSums(is.na(x))
sum(rowSums(is.na(x))>0) // NaN이 포함된 행갯수
sum(is.na(x)) // NaN 총갯수

# 결측값을 제외하고 새로운 데이터셋 만들기
head(x)
x[!complete.cases(x),]
y <- x[!complete.cases(x),]
head(y)

# 특이값
  데이터를 파악할때 왜곡을 가져올 수 있으므로 분석할 때 특이값을 제외하는 경우가 많음. 불량제품이나 사기거래탐지할 때 유용.

st <- data.frame(state.x77)
boxplot(st$Income)
boxplot.stats(st$Income)$out // out은 특이값을 표현한다.


out.val <- boxplot.stats(st$Income)$out // 특이값 추출
st$Income[st$Income %in% out.val] <- NA // 특이값을 NA로 대체
head(st)
newdata <- st[complete.cases(st),] 	// NA가 포함된 행 제거
head(newdata)

# 데이터 정렬
1. 벡터의 정렬
v1 <- c(1,7,6,8,4,2,3)
order(v1)
v1 <- sort(v1)
v1
v2 <- sort(v1, decreasing=T)
v2

2. 매트릭스와 데이터 프레임의 정렬
order(iris$Sepal.Length)
iris[order(iris$Sepal.Length),]
iris.new <- iris[order(iris$Sepal.Length),]
head(iris.new)
iris[order(iris$Species, decreasing=T, iris$Petal.Length),]

# 데이터 분리와 선택
1. 데이터 분리
sp <- split(iris, iris$Species)
sp

2. 데이터 선택
subset(iris, Species =="setosa")
subset(iris, Sepal.Length > 7.5 & Sepal.Width >2.0)
subset(iris, Sepal.Length > 7.6, select=c(Petal.Length,Petal.Width))

# 데이터 샘플링 // 주어진 값들이 있을 때 그중에서 임의의 개수의 값들을 추출하는 작업. 데이터셋의 크기가 너무 커서 데이터 ㅜㄴ석에 시간이 많이 걸리는 경우
		   일부 데이터만 샘플링하여 대략의 결과를 미리 확인
* 복원 추출과 비복원 추출로 나뉨.

1. 행을 임의로 추출하기
idx <-  sample(1:nrow(iris), size=50, replace = FALSE)
iris.50 <-  iris[idx,]		// 50개의 행 추출
dim(iris.50)			// 행과 열의 개수 확인
head(iris.50)

2. set.seed() 함수 이해하기
sample(1:20, size=5)
set.seed(100) // 이것을 사용하면 random값이었던 sample이 고정값으로 바뀜

3. 데이터 조합
combn(1:5,3) // 1~5에서 3개를 뽑는 조합

x = c("red","green","blue","black","white")
com <- combn(x,2)
com	// x의 원소를 2개씩 봅는 조합
for(i in 1:ncol(com)) {
	cat(com[,i], "\n")
}	// 조합된 것을 출력

# 데이터 집계와 병합
1. 데이터 집계 // 2차원 데이터는 합계나 평균을 계산해야 하는 일이 많음. 이러한 작업을 집계라하며 aggregate()함수를 통해서 가능
agg <- aggregate(iris[,-5], by=list(iris$Species), FUN=mean) // iris[,-5] 집계작업을 수행할 대상, 아이리스트에서 ,-5 제외하고 by는 기준점을 잡아서 평균을 내라.
agg <- aggregate(iris[,-5], by=list(표준편차=iris$Species), FUN=sd)  // iris의 각 변수의 품종별 표준편차 출력
agg <- aggregate(mtcars, by=list(cyl=mtcars$cyl, vs=mtcars$vs), FUN=max) // 각 변수의 최대값 출력

2. 데이터 병합
* 병합(merge) : 분리된 데이터 파일을 공통 컬럼을 기준으로 하나로 합치는 작업
x <-  data.frame(name=c("a","b","C"), math=c(90,80,40))
y <- data.frame(name=c("a","b","d"), math=c(75,60,90))
z <-  merge(x,y, by=c("name"))

merge(x,y, all.x=T)
merge(x,y, all.y=T)
merge(x,y, all=T)

# 결측값 처리
is.na : NA인 데이터가 있으면 T, 없으면 F
na.omit : NA인 데이터를 제거. 즉, NA가 포함된 행을 지운다
함수의 속성을 이용 : na.rm=T로 하여 함수 수행 시 NA를 제외

table(is.na(airquality))

air_narm1=na.omit(airquality)
mean(air_narm1$Ozone) 

# 이상값 처리 // 이상한 데이터
patient=data.frame(name=c("환자1","환자2","환자3","환자4","환자5"), age=c(22, 20, 25, 30, 27), gender=factor(c("M","F","M","K","F")), blood.type=factor(c("A","O","B","AB","C")))
patient_outrm=patient[patient$gender=="M"|patient$gender=="F",] // K라는 이상값을 뽑아내기 위해서
patient_outrm

patient[!is.na(patient$gender)&!is.na(patient$blood.type),]// na가 아닌값들만 출력

boxplot(airquality[, c(1:4)]) 
boxplot(airquality[,1])$stats // Ozone의 boxplot 통계값 계산

# base R을 이용한 데이터 가공
* gapminder 라이브러리

# glimpse(gapminder)
gapminder[gapminder$country == "Croatia", "pop"]

# dplyr 라이브러리를 이용한 데이터 가공
* %>% 





@ 단일변수 자료의 탐색
# 자료의 종류
1. 범주형 자료(질적 자료)
* 기본적으로 숫자로 표현할 수 없고, 대소비교나 산술연산이 적용되지 않음. ex)성별, 혈액형, 선호색 등등
2. 연속형 자료(양적 자료)
* 크기가 있는 숫자로 구성, 대소 비교가 가능하고, 평균, 최댓값, 최소값과 같은 산술 연산이 가능.

# 단일변수, 다중변수
* 단일 변수자료는 벡터, 다중 변수자료는 매트릭스나 데이터 프레임에 저장하여 분석

table(favorite) 			// 도수분포표 계산. 열의 이름마다 갯수가 나타나게됨
table(favorite)/length(favorite) 	// 비율 출력

ds <- table(favorite) // 그래프 그릴때 table 작업이 선행되어야 하구나.
barplot(ds, main='favorite season') 	// 막대그래프 형. main은 이 표의 제목
pie(ds, main='favorite season')		// 원그래프 형

weight <- c(60,62,64,65,68,69)
median(weight) // 중앙값
mean(weight, trim=0.2) // 절사평균(상하위 20% 제외)

* 4분위수 : 앞에서부터 Q1, Q2(중앙값), Q3이라고 부름

mydata <- c(60,62,64,65,68,69,120)
quantile(mydata)
quantile(mydata, (0:10)/10) // 10% 단위로 구간을 나누어 계산
summary(mydata)

var(mydata)		// 분산		
sd(mydata)		// 표준편차
range(mydata)		// 값의 범위
diff(range(mydata)) 	// 최댓값, 최솟값의 차이

hist(dist,		// 히스토그램 : 연속형자료들의 시각화. 키같은것은 범위에 애매하기때문에 일정한 구간을 정해줌.
     main="Histogram for 제동거리",
     xlab = "제동거리",
     ylab = "빈도수",
     border= "red",
     col= "green",
     las= 2,
     breaks=5)

* 막대그래프 vs 히스토그램
1. 막대그래프는 막대끼리 떨어져있지만 히스토그램은 전부붙어있다.(구간이기 때문에!)
2. 막대그래프에서는 막대의 면적이 의미가 없지만 히스토그램에서는 막대의 면적도 의미가 있음.

dist <- cars[,2]
boxplot(dist, main="자동차 제동거리리")

boxplot.stats(dist)
$stats
[1]  2 26 36 56 93  		// 최소값,1사분위수,중앙값,3사분위수,최대값

$n
[1] 50				// 자료의 개수

$conf
[1] 29.29663 42.70337  		// 중앙값에 관련된 신뢰 구간

$out
[1] 120				// 특이값의 목록


boxplot(Petal.Length~Species, data=iris, main="품종별 꽃잎의 길이")


* 여러 그래프 그리기
par(mfrow=c(1,3)) 			// 그래프 3개 설정
barplot(table(mtcars$carb),
        main="barplot of Carburetors",
        xlab="#of carburetors",
        ylab="frequency",
        col="blue"
        )
barplot(table(mtcars$cyl),
        main= "barplot of Cylender",
        xlab="#of carburetors",
        ylab="frequency",
        col="red")
barplot(table(mtcars$gear),
        main="Barplot of Grar",
        xlab="#of carburetors",
        ylab="frequency",
        col="green")
par(mfrow=c(1,1))			// 다시 원위치

# 다중변수 자료(다변량 자료) : 변수가 2개 이상인 자료. 따라서 표현하려면 매트릭스나 데이터 프레임이 필요하다.
* 산점도란 2개의 변수로 구성된 자료의 분포를 알아보는 그래프
plot(wt, mpg, main = "중량-연비 그래프",
        xlab="중량",
        ylab="연비",
        col="red",
        pch=19)

vars <- c("mpg","disp", "drat", "wt")
vars
mpg
wt
target <-  mtcars[,vars]
head(target)
pairs(target, main="Multi Plots") // 단일그래프는 plot, 여러가지 그래프를 그릴땐 pairs. 만약에 1행 2열에 있는 그래프를 보자면 x축이 mpg, y축이 disp

iris.2 <- iris[,3:4]			// 데이터 준비
point <- as.numeric(iris$Species)	// 점의 모양
color <- c("red","green","blue")	// 점의 컬러
plot(iris.2,
        main="Iris plot",
        pch=c(point),
        col=color[point])


# 상관분석과 상관계수
* 강한 선형적 관계 : 점들이 밀집되어있어서 하나의 선처럼 보일때
beers = c(5,2,9,8,3,7,3,5,3,5)
bal <- c(0.1,0.03,0.19,0.12,0.04,0.0095,0.07,0.06,0.02,0.05)
tbl <- data.frame(beers,bal)	
tbl
plot(bal~beers,data=tbl) 	// 산점도
res <-  lm(bal~beers,data=tbl)	// 회귀식 도출
abline(res)			// 회귀선 그리기
cor(beers,bal)			// 상관계수 계산


month = 1:12
late = c(5,8,7,9,4,6,12,13,8,6,6,4)
plot(month,late,		// x와 y데이터
main="지각생통계",
type="l",			// 그래프의 종류 선택
lty=1,				// 선의 종류 선택
lwd=1,				// 선의 굵기 선택
xlab="Month",			// x축 레이블
ylab="Late cnt")		// y축 레이블

* 선그래프. 시계열 그래프라고함.
* 복수의 선그래프 작성
month = 1:12
late1 = c(5,8,7,9,4,6,12,13,8,6,6,4)
late2 = c(4,6,5,8,7,8,10,11,6,5,7,3)
plot(month,late1,
     main="Late Student",
     type="b",			// 그래프의 종류 
     lty=1,			// 선의 종류
     col="red",			// 선의 색
     xlab="Month",		
     ylab="Late cnt",
     ylim=c(1,15)		// y축 값의 (하한, 상한)
     )

* grp 변수추가
grp <- c()					// grp는 주택가격을 상중하로 분류. 25.0이상이면 상 17이면 하, 나머지 중으로 분류
for(i in 1:nrow(myds)){
        if(myds$medv[i] >= 25.0){
                grp[i] <- "H"
        } else if(myds$medv[i] <= 17.0){
                grp[i] <- "L"
        } else {
                grp[i] <- "M"
        }
        
}
str(grp)

grp <- factor(grp)
grp <- factor(grp, levels=c("H","M","L"))
grp
myds <- data.frame(myds, grp)
myds

* 여러그래프 비교
par(mfrow=c(2,3))
for(i in 1:5){
        hist(myds[,i], main=colnames(myds)[i], col="yellow")
}

myds

* 상자그림으로 비교
par(mfrow=c(2,3))
for(i in 1:5){
        boxplot(myds[,i], main=colnames(myds)[i])
}
par(mfrow=c(1,1)) // 가상화면 분할 이거 꼭해줄 것.

* 다중 산점도를 통한 변수간 상관 관계의 확인
pairs(myds[,-6])

* 그룹 정보를 포함한 변수 간 상관관계의 확인
point <- as.integer(myds$grp)			// 점의 모양 설정
color <- c("red","green","blue")		// 점의 색 지정
pairs(myds[,-6], pch=point, col=color[point])

* 다중 그래프 
height1 <- c(4,18,5,8)
height2 <- c(9,15,20,6)
height <- rbind(height1, height2)
height
name <- c("영업1팀","영업2팀","영업3팀","영업4팀")
legend_lbl <- c("2014년","2015년")

barplot(height, main="부서별 영업 실적",
        names.arg=name,
        xlab="부서", ylab="영업 실적(억원)",
        col=c("darkblue","red"),
        legend.text=legend_lbl,
        ylim=c(0,35)
        )
boxplot(mag, main="지진발생강도의 분포", xlab="지진강도", ylab="발생건수수", col="red")

* 트리맵
library(treemap)
treemap
data(GNI2014)
head(GNI2014)

treemap(GNI2014,
        index=c("continent","iso3"),	// 계층구조 설정
        vSize="population",		// 타일의 크기
        vColor="GNI",			// 타일의 컬러
        type="value",			// 타일 컬러링 방법
        bg.labels="yellow",		// 레이블의 배경색
        title="World's GNI")		// 트리맵 제목

st <- data.frame(state.x77)
symbols(st$Illiteracy, st$Murder,	
        circles=st$Population,		// 원의 반지름의 열
        inchec=0.3,			// 원의 크기 조절값
        fg="white",			// 원의 테두리 색
        bg="lightgray",			// 원의 바탕색
        lwd=1.5,			// 원의 테두리선 두께
        xlab="rate of Olliteracy",
        ylab="crime(murder) rate",
        main="illiteracy and Crime")

text(st$Illiteracy,st$Murder,		// 텍스트가 출력될 x,y좌표
     rownames(st),			// 출력할 텍스트
     cex=0.6,				// 폰트 크기
     col="brown")			// 폰트 컬러

* 모자이크플롯
head(mtcars)
mosaicplot(~gear+vs, data = mtcars, color=TRUE,
           main = "Gear and VS")

* ggplot 패키지
month <- c(1,2,3,4,5,6)						// 월을 표현
rain <- c(55,50,45,50,60,70)					// 강수량
df <- data.frame(month,rain)					// 그래프를 작성할 대상 데이터
ggplot(df, aes(x=month,y=rain))					// 그래프를 그릴 데이터 지정
geom_bar(stat="identity", width=0.7, fill="steelblue")		// 막대의 높이는 y축에 해당하는 열의 값, 막대의 폭과 색 지정.

* ggplot으로 히스토그램 그리기
ggplot(iris, aes(x=Petal.Length)) + geom_histogram(binwidth=0.5)


# 크롤링
* 남의 사이트에서 가져오는것. 스크래핑이라고도 한다.
1. rvest랑 stringr 다운받고 메모리 올리기
2. URL복사 : https://www.coupang.com/np/search?q=%EC%97%AC%EC%84%B1%ED%81%AC%EB%A1%9C%EC%8A%A4%EB%B0%B1&channel=user&component=&eventCategory=SRP&trcid=&traid=&sorter=scoreDesc&minPrice
=&maxPrice=&priceRange=&filterType=&listSize=36&filter=&isPriceRange=false&brand=&offerCondition=&rating=0&page=1 // 페이지까지만 사용!

3. reply_list <-  character() 				// 상품명
   reply_list2 <- numeric()				// 가격 

3. content <- read_html(mainURL) 			// 주소 읽어오기

4. node_1 <- html_nodes(content, ".name")		// 상품명
   node_2 <- html_nodes(content, ".price-value")	// 가격
	
5. reply1 <- html_text(node_1)				// DOM형식으로 받아오기
   reply2 <- html_text(node_2)  			
	
6. reply_list <- append(reply_list, reply1)		// node들 떼버리고 String만
   reply_list2 <- append(reply_list2, reply2)

7. df <- data.frame(reply_list, reply_list2)		// data.frame으로 만들기

8. colnames(df) = c("품명","가격")			// 열 이름 지정

9. setwd("c:/source")					// 파일로 만들기
   write.csv(df,"여성가방.csv",sep=",",row.names=FALSE)

10. View(df)						// 도표로 보기


1. 스크래핑 대상 URL 할당
2. 웹문서추출
3. 상품정보 추출
4. 데이터 정제
5. 데이터 프레임만들기
6. 데이터 정렬

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
mainURL <- "https://www.coupang.com/np/search?q=%EC%97%AC%EC%84%B1%ED%81%AC%EB%A1%9C%EC%8A%A4%EB%B0%B1&channel=user&component=&eventCategory=SRP&trcid=&traid=&sorter=scoreDesc&minPrice=&maxPrice=&priceRange=&filterType=&listSize=36&filter=&isPriceRange=false&brand=&offerCondition=&rating=0&page=1"
reply_list <-  character()
reply_list2 <- numeric()

content <- read_html(mainURL)
content       

node_1 <- html_nodes(content, ".name")
node_2 <- html_nodes(content, ".price-value")   

reply1 <- html_text(node_1)
reply2 <- html_text(node_2)                                                                                                                                                                                    

reply_list <- append(reply_list, reply1)
reply_list2 <- append(reply_list2, reply2)

df <- data.frame(reply_list, reply_list2)
View(df)

colnames(df) = c("품명","가격")

setwd("c:/source")
write.csv(df,"여성가방.csv",sep=",",row.names=FALSE)

View(df)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
* for문으로 페이지 마다 따오기
for(pgCnt in 1:10){
  url <- paste0(mainURL, pgCnt)
  content <- read_html(url)
  
  node_1 <- html_nodes(content, ".name")
  node_2 <- html_nodes(content, ".price-value")   
  
  reply1 <- html_text(node_1)
  reply2 <- html_text(node_2)                                                                                                                                                                                    
  
  reply_list <- append(reply_list, reply1)
  reply_list2 <- append(reply_list2, reply2)
  df <- data.frame(reply_list, reply_list2)
  
  colnames(df) = c("품명","가격")
  
  setwd("c:/source")
  write.csv(df,"여성가방.csv",row.names=FALSE, sep=",")
}