https://blog.naver.com/spdlqjdudghl

https://beomy.tistory.com/43  - mvp 패턴

https://www.data.go.kr/


* chage -l user_001 // 유저 정보보기
* find -user 1001 -exec rm -r { } \;   // 파일 내용중에서 UID를 찾아서 관련된 파일을 모두 삭제
* groupadd db_zone 	// 그룹 아이디 만들기
** grep db_zone /etc/group // 만들고 확인!
*** groupadd -g 2017 nt_zone // 그룹아이디 주기
**** gpasswd -a sno_2017001 db_zone // sno_2017001을 db_zone에 그룹추가


/////////////////////////////////////////////////////////////////////////////////////////////////////////////

* a <-(alt+"-") 10 은 a = 10
* ctrl + shift + r // 전체실행
* install.packages("ggplot2") // 설치한 패키지 불러오기
* tips=read.csv('https://raw.githubusercontent.com/mwaskom/seaborn-data/master/tips.csv') //  read.으로 변수 불러오기
* str(tips)

* lib

* 'data.frame':	244 obs. of  7 variables:
  data.frame // 데이터 형식
  244 obs. // 관측된 것들
  7 variables // 7개의 변수

* summary(tips) // 요약

* install된거 메모리올리기
  library(dplyr) 
  library(ggplot2)

* 그래프 실행
tips%>%ggplot(aes(size)) + geom_histogram()
tips%>%ggplot(aes(total_bill, tip)) + geom_point()
tips%>%ggplot(aes(total_bill, tip)) + geom_point(aes(col=day))
tips%>%ggplot(aes(total_bill, tip)) + geom_point(aes(col=day, pch=sex), size=3)

* 함수
log(10) + 5 // 로그함수
sqrt(25) // 제곱근
max(5,3,2) // 가장큰 값
min()
abs(-10)
factorial(5)
sin(pi/2), cos(), tan()

* 데이터타입
숫자형 1, 2, 3, -4, 12.8
문자형 'TOM', "JANE"
논리형 TRUE, FALSE
특수값 null, na(missing value), NaN, Inf, -Int

* 벡터는 1차원 배열 데이터 ex) 몸무게 30, 32, 38
  매트리스, 데이터프레임은 2차원 배열 데이터 x, y로 row와 col로 구성

* w <- c(1,2,3,"a","b","C") // 전부다 문자열로 바뀜

* v2 <- c(1,2,5, 50:90) // 1,2,5 찍고 50~90까지

* v3 <- seq(1,101,3) // 1부터 3씩 더하면서 101번까지 찍고 seq해라

* 반복문
  v4 <- rep(1:5, times=3)
  v5 <-  rep(c(1,5,9), times=3)

* 2차원으로 바꾸기
  score <- c(90,85,60)
  names(score) <- c("A","B","C")

* v1[10] // 벡터값의 10번째방

* 배열 방으로 보는 방법
d <- c(1,4,3,7,8)
d[c(1,3,5)]
d[1:3]
d[seq(1,5,2)]
d[-2]
d[-c(3:5)]
score

* 벡터에 적용 가능한 함수 찾아보기

* sort(d, decreasing = TRUE)

## 리스트 : 서로 다른 자료형들의 값들을 1차원 배열에 저장하고 다룰 수 있다
  my.info <- list(name='Tom','Jerry', age=60, status=TRUE, score=ds)
  my.info[[5]]

* 데이터 셋의 기본정보 확인.
dim(iris)
nrow(iris)
ncol(iris)
colnames(iris)
head(iris)
tail(iris)
str(iris) // 데이터 분석
unique(iris[,5]) // 중복제거
table(iris[,"Species"]) // 품종의 종류별 개수 세기


## 팩터 : 문자형 데이터가 저장된 벡터의 일종. 성별이나 혈액형, 선호 정당 등과 같이 저장할 문자값들이 fix되어있을때 팩터를 사용. 레벨이 있음
** 팩터의 선언
bt <- c('A','B','C','O','AB','A')  // 만약에 여기다 E를 넣으면 오류남.
bt.new <-  factor(bt)
** 팩터값 레벨 조회
levels(bt.new)
** 팩터값 조회
bt.new

## 매트릭스 : 2차원 데이터라고도 함.(1차원은 벡터) 키,몸무게,나이 등 여러 주제의 데이터. 벡터들의 모임이라 할 수 있다. *** 모든 셀의 데이터타입이 같다!
* 행은 관측값(observation), 열은 변수(variable)라고 함

* z <- matrix(1:20, nrow=4, ncol=5) // 1~20까지 열단위로 먼저 들어감.
** z2 <- matrix(1:20, nrow=4, ncol=5, byrow=T) // 행단위로 먼저 들어감.

* 이해할 것!
x <-1:4
y <- 5:8
z <- matrix(1:20, nrow=4, ncol=5)

m1 <- cbind(x,y)

z[2,4] // 조회방법
z[1:2,] // 1행과 2행만 다 나와라
z[,c(1,4)] // 1열과 4열만 다 나와라

* 매트릭스 이름 정하기
rownames(z) <- c('a','b','c','d')
colnames(z) <- c('e','f','g','h','i')
m2 <- rbind(x,y)
z['a','i']
colnames(z)[3]

## 데이터 프레임 : *** 자료형이 다른 컬럼으로 구성되어있다
* 데이터 프레임 만드는 방법
city <- c("seoul","tokyo","washington")
rank <- c(1,3,2)
city.info <- data.frame(city,rank)
city.info

## 매트릭스와 데이터 프레임에서 사용하는 함수.
colSums(iris[,-5]) // 열별 합계
colMeans(iris[,-5]) // 열별 평균
rowSums(iris[,-5])

* 행과 열 자리바꾸기
z <- matrix(1:20, nrow=4, ncol=5)
t(z)
* 원하는 정보 가져오기
IR.1 <- subset(iris, Species=="setosa")
IR.2 <- subset(iris, Sepal.Length>5.0 & Sepal.Width>4.0)
IR.2[, c(2,4)]
* 산술연산

* 매트릭스와 데이터프레임의 자료구조 확인
class(iris) // iris 데이터셋의 자류구조 확인
is.matrix(iris), is.data.frame(iris)

* 매트릭스와 데이터프레임의 자류구조 변환
st <- data.frame(state.x77)
iris.m <- as.matrix(iris[,1:4])

* 구분할 것.
iris["Species"] // 벡터, 매트릭스와 데이터프레임 모두 가능.
iris[,"Species"] // 데이터프레임, 데이터프레임만 가능. iris[,5]와 같다.
iris$Species // 벡터. 데이터프레임만 가능

## 리스트 : 서로 다른 기본 데이터형을 갖는자료 구조를 포함함. 데이터 프레임보다 넓은 의미의 데이터 모임. 
            *** 데이터 프레임과 달리 모든 속성의 크기가 같을 필요가 없음
ds <- c(90,85,70,84)
my.info <- list(name='TOM',age=60, status=TRUE, score=ds) // 리스트 만드는 방법
my.info
my.info[[4]]
my.info$score // 리스트에서 값의 이름이 name인 값 출력

patients = data.frame(name=c("철수","춘향","길동"), age= c(22,20,25), gender = factor(c("M","F","M")), blood.type = factor(c("A","O","B")))
no.patients = data.frame(day=c(1:6), no=c(50,60,70,80,90,65))
listPatients = list(patients, no.patients)
listPatients = list(patients = patients, no.patients = no.patients) // 요소에 이름주기

listPatients$patients // 위의 이름으로 출력가능.
listPatients[[1]]
listPatients[["patients"]]

* 유용한 함수들
** apply : 행렬이나 데이터 프레임을 행 단위로, 또는 열 단위로 행렬의 합이나 평균, 표준편차 등을 계산할 때 씀.
apply(no.patients,1,sum) // 여기서 1은 행을 의미, 2는 열. 1과 2로 행렬을 구분한다.
lapply(listPatients$no.patients, mean) // 데이터타입을 list로 리턴.
sapply(listPatients$no.patients, mean) // 데이터타입이 벡터. 평균내는 두가지 형태의 함수

** tapply : 벡터 등에 있는 데이터를 특정 기준으로 묶어 그룹마다 특정 함수 적용
tapply(weigth.furit,mean) // 과일을 기준으로 평균을 구해라.
tapply(iris$Sepal.Width, iris$Species, sum) // 종을 기준으로

** 패키지와 함수 // RStudio에서 우측하단의 인스톨을 통하여 설치해야 함.
base 기본 패키지
readr 패키지
data.table 패키지
feather 패키지

** 파일 형식 변환 // 엑셀파일에 테이블 형태의 데이터가 저장된 상태에서 .csv형태로 변환하여 R에서 .csv파일을 읽음. 이 파일은 데이터 프레임 형태로 저장됨.
setwd("C:/source") // 여기 경로의 폴더에 존재하는 csv(Comma-Separated Values)파일 갖고오는 것.(setworkingdirectory의 약자)
air <- read.csv("airquality.csv", header=T) // csv파일 읽을때
head(air)
air <- read.table("airquality.txt", header=T) // txt파일 읽을때

* csv는 이런 파일임.
name,korean,english
조씨,60,60
김씨,70,70
이씨,80,50	
박씨,60,50	

* txt파일은 띄어쓰기로 구분
name korean english
조씨 60 60
김씨 70 70
이씨 80 50	
박씨 60 50

write.csv(listPatients, file="c://source/output.csv", quote=F)	 // csv파일로 저장
write.table(listPatients, file="c://source/output2.txt", quote=F) // 텍스트파일로 저장 quote=f는 따옴표가 없음.

setwd("C:/source")
my.iris <- subset(iris, Species='Setosa')
write.csv(my.iris, "my_iris.csv", row.names=F) // row.names=F는 행번호 붙이지 않을 때.



## 조건문
job.type <- 'A'
if(job.type == 'B'){
    bonus <- 200
} else { 
    bonus <- 100
}
print(bonus)

a <- 10
b <- 20
c <- ifelse(a>b, a,b) // 3항연산자. true면 a, false면 b

x=c(-5:5)
options(digits=3) // 숫자 표현 시 유효자릿수를 3자리로 설정
sqrt(x) // NaN이 포함되어있어서 오류발생! sqrt는 루트를 의미함.
sqrt(ifelse(x>=0, x, NA)) // 따라서 이렇게 해결해줘야 함.
## 반복문
for (반복변수 in 반복범위){
	반복할 명령문(들)
}

for(i in 1:5){
  print(i);
}

for(i in 1:9){
  cat('2*', i, '=', 2*i,'\n');
}	// 구구단의 2단 만들기

for(i in 1:20){
  if(i%%2==0){
    print(i)
  }
} 	// 짝수만 출력하기

* 강제로 값 바꾸기
x <- iris
x[1,2] <- NA; x[1,3] <- NA
x[2,3] <- NA; x[3,4] <- NA

# 데이터 프레임의 열별 결측값 확인
** for문을 이용한 방법
for(i in 1:ncol(x)){
  this.na <-  is.na(x[,i]) // na는 NaN. 그게 몇개가 있느냐
  cat(colnames(x)[i], "\t", sum(this.na), "\n")
}

** apply를 이용한 방법
col_na <-  function(y){
  return(sum(is.na(y)))
}
na_count <-  apply(x, 2, FUN=col_na)
na_count

# 데이터 프레임의 행별 결측값 확인
rowSums(is.na(x))
sum(rowSums(is.na(x))>0) // NaN이 포함된 행갯수
sum(is.na(x)) // NaN 총갯수

# 결측값을 제외하고 새로운 데이터셋 만들기
head(x)
x[!complete.cases(x),]
y <- x[!complete.cases(x),]
head(y)