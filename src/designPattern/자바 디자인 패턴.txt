@ 모든 패턴들의 구조와 구현의 분리를 이해하고 그것의 장점을 최대한 살려야 한다.

# 생성 패턴 : 객체의 생성과 관련된 패턴으로 객체의 생성과 참조 과정을 캡슐화하여 객체가 생성되거나 변경되어도 크게 영향을 받지 않도록하여 프로그램의 "유연성"을 더해준다.
* "팩토리 메소드" 패턴 : 팩토리 메소드 패턴에서 템플릿 메소드 패턴이 사용되는 것을 안다.
   우리가 나중에 다른 아이템을 생성할 때 다른 소스 변경(Main같은)이 필요가 없다.
   ** 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴이다.
   ** 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다.

* 싱글톤 패턴 : 싱글톤 패턴을 통해서 하나의 인스턴스만 생성하도록 구현할 수 있다. 하나만 생성해야할 인스턴스를 위한 패턴
   객체 : 속성과 기능을 갖춘 것
   클래스 : 속성과 기능을 정의한 것 (자동차 설계도)
   인스턴스 : 클래스 중 실제 구현된 것 (만들어진 자동차) 
   ex) 인스턴스를 호출할 때 로그를 찍어주는 소스를 추가할 때, 사용자 방문 카운트할 때 
   ** 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없다.
   ** 클래시 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화할 수 있다.



# 구조 패턴 : 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴으로 구조가 복잡한 시스템을 개발하기 쉽게 도와준다.
* "어댑터" 패턴 : 알고리즘을 요구사항에 맞춰 사용할 수 있다.
   특정한 알고리즘을 가진 클래스를 Adapter역할을 하는 인터페이스와 하위클래스를 구성하여 Main과 이미 
   정해진 알고리즘을 수정안하더라도 Adapter 인터페이스를 거치면 각각 다른 결과가 도출된다.
   ** 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴이다.
   ** 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용한다.

# 행위 패턴 : 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴으로 하나의 객체로 수행할 수 없는 작업을 여러 객체로 분배하면서 결합도를 최소화 할 수 있도록 도와준다.
* "전략" 패턴 : 인터페이스, 델리게이트 개념을 이해하여 사용한다.
   1개의 인터페이스에서 같은 메소드를 받는 3개의 클래스로 갈라져서 클라이언트가 접근점 역할을 하는 클래스에 Delegate메서드를 구현하여 사용한다.
   ** 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴이다.
   ** 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향없이 알고리즘의 변경이 가능하다.

* "템플릿 메소드" 패턴 : 일정한 프로세스를 가진 요구사항을 템플릿 메소드 패턴을 이용하여 구현할 수 있다.
   지속적인 발전이 있어야하는 "보안"같은 분야에서 효과적인 유지보수! 
   구현하려는 알고리즘이 "일정한 프로세스(여러 단계로 나눌 수 있을 때)"가 있고 "변경 가능성"이 있을 때 사용한다.
   알고리즘의 구조를 메소드에 정의하고 하위 클래스에서 알고리즘 구조의 변경없이 알고리즘을 재정의 하는 패턴.
   1. 알고리즘을 여러 단계로 나눈다.   
   2. 나눠진 알고리즘의 단계를 메소드로 선언한다.
   3. 알고리즘을 수행할 템플릿 메소드를 만든다.
   4. 하위 클래스에서 나눠진 메소드들을 구현한다.
   ** 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴이다.
   ** 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해준다.


